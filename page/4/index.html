<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />


  <meta name="google-site-verification" content="005735843669583756565:phrkilwibwg" />







  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>


    <meta name="description" content="去发现更大的世界！" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description" content="去发现更大的世界！">
<meta property="og:type" content="website">
<meta property="og:title" content="niko">
<meta property="og:url" content="http://niko2014.github.io/page/4/index.html">
<meta property="og:site_name" content="niko">
<meta property="og:description" content="去发现更大的世界！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="niko">
<meta name="twitter:description" content="去发现更大的世界！">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'always'
  };
</script>



  <title> niko </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?c4a2e0d0f7d88e69bc22f35fd12b1f3f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">niko</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/01/26/linux/tools/cheat-cmd/" itemprop="url">
                  man的铺助工具——cheat
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-26T00:00:00+08:00" content="2016-01-26">
              2016-01-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/26/linux/tools/cheat-cmd/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/26/linux/tools/cheat-cmd/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="man"><a href="#man" class="headerlink" title="man"></a>man</h1><p>相信使用Linux的小伙伴, 想要查询一个命令的用法时, 都会使用<code>man</code>命令数据库，或者试一试命令自带的<code>--help</code>参数。<br>但是使用<code>man</code>有个不好的地方，就是信息太多太全了，对我们来说，需要的可能只是某个用法，而且例子是比较少的，有时man的效率确实比较低。<br>所以我的习惯是，写博客和笔记，并附有许多常用的例子。<br>其实，还有一个常用工具，可以满足需求的——<code>cheat</code>。</p>
<h1 id="cheat-命令"><a href="#cheat-命令" class="headerlink" title="cheat 命令"></a>cheat 命令</h1><p>首先，看一下效果，以tar为例：</p>
<p><img src="/images/linux/linux-python-cheat-tar.png" alt=""></p>
<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>cheat是python写的，可以用pip安装。</p>
<pre><code>pip install cheat
</code></pre><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><hr>
<p><a href="https://github.com/chrisallenlane/cheat" target="_blank" rel="external">github 地址</a></p>
<p>#</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/01/13/linux/synergy/" itemprop="url">
                  synergy 安装和使用 （一套键鼠掌握世界）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-13T15:03:30+08:00" content="2016-01-13">
              2016-01-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/13/linux/synergy/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/13/linux/synergy/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>由于有两台电脑，四个显示器，在使用的时候，难免要切换，但笔记本的触控板和键盘实在太难用～<code>%&gt;_&lt;%</code> 但是机械键盘和鼠标只有一套，怎么办呢？<br>还好之前看一些大牛的工作环境时，看到有一个工具叫synergy，用来同步鼠标和键盘，可以随意在多台电脑中切换。</p>
<h1 id="通过apt-get-安装"><a href="#通过apt-get-安装" class="headerlink" title="通过apt-get 安装"></a>通过apt-get 安装</h1><p>因为我常用的操作系统是ubuntu和kali，当然是直接apt-get。</p>
<pre><code>apt-get install synergy
</code></pre><p>安装后，两台ubuntu（synergy版本1.4.12）之间操作没问题，然而在kali上是1.4.16版本，有不兼容的问题。于是找了下源，并没有找到对应的仓库，干脆就两边使用最新的源码install好了。</p>
<h1 id="通过源码安装"><a href="#通过源码安装" class="headerlink" title="通过源码安装"></a>通过源码安装</h1><p>首先，安装依赖</p>
<pre><code>sudo apt-get install cmake make g++ xorg-dev libqt4-dev libcurl4-openssl-dev libavahi-compat-libdnssd-dev libssl-dev
</code></pre><p>访问<a href="https://github.com/symless/synergy/releases" target="_blank" rel="external">synergy on github</a>，git clone或者直接<a href="https://github.com/symless/synergy/archive/v1.7.5-stable.tar.gz" target="_blank" rel="external">下载</a>，然后：</p>
<pre><code>tar xzvf v1.7.5-stable.tar.gz
cd synergy-1.7.5-stable
./hm conf -g1
./hm build
</code></pre><p>搞定。kali上也是如此操作，因为也是基于Debian。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>跟着上面的操作，工作目录还在<code>synergy-1.7.5-stable</code>，执行<code>bin/synergy</code></p>
<p>1，开启服务器（服务器即是你鼠标和键盘连接的那台电脑），synergy 会有个向导，选择服务器模式；<br>2，点击<code>Configure Server</code>，拖拽显示右上角的显示到格子中，想要的放置位置，这里要注意显示器的name需要填写正确，这个name就是client（或server）的名称，client若对不上，会被server拒绝连接的（name在<code>Edit - Settings</code>中设置）。</p>
<p><img src="/images/synergy_server_conf.png" alt=""><br><img src="/images/synergy_name_settings.png" alt=""></p>
<p>3，主界面点击start，界面可以看到log，包括客户端的连接。<br>4，启动server后，其他主机同样<code>bin/synergy</code>启动，选择client模式，接着设置一下自己的name，填写server的IP，点击<code>Start</code>。<br>5，Okay，这时可以发现，一套键鼠可以操控多台计算机啦，尽情地享受多屏多机的快感吧，工作效率杠杠的。    :-D</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/01/12/java/spring/spring_transaction_manager/" itemprop="url">
                  【spring】事务提交后进行某些操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-12T13:03:30+08:00" content="2016-01-12">
              2016-01-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/12/java/spring/spring_transaction_manager/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/12/java/spring/spring_transaction_manager/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>在工作中，我们经常会有这样的需求。当修改了某些东西后，需要通知其他服务模块或系统进行某些处理。<br>这个如果硬编码的话，是一种很不优雅的方法：<br>首先，它的灵活性很差，当需求变更时，无可避免的要修改业务操作的代码，容易出bug，不符合<code>开关</code>原则（虽然不是讨论设计模式）。<br>其次，主业务操作（数据修改）部分和后续的通知处理应该是隔离的，后续的通知是否成功，对业务操作都不应有影响，或者在功能和时间上尽可能不影响主业务操作。</p>
<p>那么如果不用硬编码，事件（消息）驱动的方式是常用的一种方法，这样我们就可以把后续通知的相关处理和主业务操作解耦开来，就算要进行拓展也是很安全和方便的。</p>
<h2 id="spring-的-TransactionSynchronizationManager"><a href="#spring-的-TransactionSynchronizationManager" class="headerlink" title="spring 的 TransactionSynchronizationManager"></a>spring 的 TransactionSynchronizationManager</h2><p>在spring中，TransactionSynchronizationManager有一个事务提交后的回调支持，我们可以视线注册需要在事务commit后才进行的某些操作，如<code>afterCommit()</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 这里是上下文</div><div class="line">TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() &#123;</div><div class="line">        @Override</div><div class="line">        public void suspend() &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void resume() &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void flush() &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void beforeCommit(boolean readOnly) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void beforeCompletion() &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void afterCommit() &#123;</div><div class="line">            log.info(&apos;afterCommit()&apos;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void afterCompletion(int status) &#123;</div><div class="line">        &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>因为TransactionSynchronization是interface，所以TransactionSynchronization的实现是一个匿名内部类，相当于一个闭包，可以访问上下文的变量等，方便我们进行某些操作。</p>
<h2 id="运行细节-源码"><a href="#运行细节-源码" class="headerlink" title="运行细节 ( 源码 )"></a>运行细节 ( 源码 )</h2><p>接下来看一下TransactionSynchronizationManager的实现，它的成员中，有个ThreadLocal副本，保存了不同线程已注册的同步操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</div><div class="line">			new NamedThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt;(&quot;Transaction synchronizations&quot;);</div></pre></td></tr></table></figure>
<p>在spring运行过程中，事务相关的操作会通过TransactionInterceptor执行invocation：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class TransactionInterceptor extends TransactionAspectSupport implements MethodInterceptor, Serializable &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">	public Object invoke(final MethodInvocation invocation) throws Throwable &#123;</div><div class="line">		// Work out the target class: may be &#123;@code null&#125;.</div><div class="line">		// The TransactionAttributeSource should be passed the target class</div><div class="line">		// as well as the method, which may be from an interface.</div><div class="line">		Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);</div><div class="line"></div><div class="line">		// Adapt to TransactionAspectSupport&apos;s invokeWithinTransaction...</div><div class="line">		return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() &#123;</div><div class="line">			@Override</div><div class="line">			public Object proceedWithInvocation() throws Throwable &#123;</div><div class="line">				return invocation.proceed();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">    protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation)</div><div class="line">			throws Throwable &#123;</div><div class="line">            ...</div><div class="line">            ...</div><div class="line">			commitTransactionAfterReturning(txInfo);</div><div class="line">			return retVal;</div><div class="line">		&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>invokeWithinTransaction()是父类TransactionAspectSupport的方法，并会调用commitTransactionAfterReturning(TransactionInfo txInfo))来提交事务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">   // TransactionInterceptor.java</div><div class="line"></div><div class="line">   protected void commitTransactionAfterReturning(TransactionInfo txInfo) &#123;</div><div class="line">	if (txInfo != null &amp;&amp; txInfo.hasTransaction()) &#123;</div><div class="line">		if (logger.isTraceEnabled()) &#123;</div><div class="line">			logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);</div><div class="line">		&#125;</div><div class="line">		txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// AbstractPlatformTransactionManager.java</div><div class="line"></div><div class="line">@Override</div><div class="line">public final void commit(TransactionStatus status) throws TransactionException &#123;</div><div class="line">    ...</div><div class="line">	processCommit(defStatus);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>processCommit()这个方法中很详细的介绍了提交事务的处理细节，包括beforeCommit() / beforeCompletion() / afterCommit() / afterCompletion()在事务提交时的调用和发生异常时的处理方法，还可以看到如isNewTransaction、globalRollbackOnly等对事务处理的影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private void processCommit(DefaultTransactionStatus status) throws TransactionException &#123;</div><div class="line">    try &#123;</div><div class="line">        boolean beforeCompletionInvoked = false;</div><div class="line">        try &#123;</div><div class="line">            prepareForCommit(status);</div><div class="line">            triggerBeforeCommit(status);</div><div class="line">            triggerBeforeCompletion(status);</div><div class="line">            beforeCompletionInvoked = true;</div><div class="line">            boolean globalRollbackOnly = false;</div><div class="line">            if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</div><div class="line">                globalRollbackOnly = status.isGlobalRollbackOnly();</div><div class="line">            &#125;</div><div class="line">            if (status.hasSavepoint()) &#123;</div><div class="line">                if (status.isDebug()) &#123;</div><div class="line">                    logger.debug(&quot;Releasing transaction savepoint&quot;);</div><div class="line">                &#125;</div><div class="line">                status.releaseHeldSavepoint();</div><div class="line">            &#125;</div><div class="line">            else if (status.isNewTransaction()) &#123;</div><div class="line">                if (status.isDebug()) &#123;</div><div class="line">                    logger.debug(&quot;Initiating transaction commit&quot;);</div><div class="line">                &#125;</div><div class="line">                doCommit(status);</div><div class="line">            &#125;</div><div class="line">            // Throw UnexpectedRollbackException if we have a global rollback-only</div><div class="line">            // marker but still didn&apos;t get a corresponding exception from commit.</div><div class="line">            if (globalRollbackOnly) &#123;</div><div class="line">                throw new UnexpectedRollbackException(</div><div class="line">                        &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        catch (UnexpectedRollbackException ex) &#123;</div><div class="line">            // can only be caused by doCommit</div><div class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</div><div class="line">            throw ex;</div><div class="line">        &#125;</div><div class="line">        catch (TransactionException ex) &#123;</div><div class="line">            // can only be caused by doCommit</div><div class="line">            if (isRollbackOnCommitFailure()) &#123;</div><div class="line">                doRollbackOnCommitException(status, ex);</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</div><div class="line">            &#125;</div><div class="line">            throw ex;</div><div class="line">        &#125;</div><div class="line">        catch (RuntimeException ex) &#123;</div><div class="line">            if (!beforeCompletionInvoked) &#123;</div><div class="line">                triggerBeforeCompletion(status);</div><div class="line">            &#125;</div><div class="line">            doRollbackOnCommitException(status, ex);</div><div class="line">            throw ex;</div><div class="line">        &#125;</div><div class="line">        catch (Error err) &#123;</div><div class="line">            if (!beforeCompletionInvoked) &#123;</div><div class="line">                triggerBeforeCompletion(status);</div><div class="line">            &#125;</div><div class="line">            doRollbackOnCommitException(status, err);</div><div class="line">            throw err;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Trigger afterCommit callbacks, with an exception thrown there</div><div class="line">        // propagated to callers but the transaction still considered as committed.</div><div class="line">        try &#123;</div><div class="line">            triggerAfterCommit(status);</div><div class="line">        &#125;</div><div class="line">        finally &#123;</div><div class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    finally &#123;</div><div class="line">        cleanupAfterCompletion(status);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到triggerAfterCommit()在doCommit(status)，不管是否抛出异常都会执行afterCompletion()，这个细节在平时开发也要留意，做好异常的处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">   private void triggerAfterCommit(DefaultTransactionStatus status) &#123;</div><div class="line">	if (status.isNewSynchronization()) &#123;</div><div class="line">		if (status.isDebug()) &#123;</div><div class="line">			logger.trace(&quot;Triggering afterCommit synchronization&quot;);</div><div class="line">		&#125;</div><div class="line">		TransactionSynchronizationUtils.triggerAfterCommit();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>终于，前面我们注册在TransactionSynchronizationManager的TransactionSynchronization，在这里被get出来执行，如果注册了多个通知操作，会被按顺序执行，因为这个Set的实现是LinkedHashSet。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">   // TransactionSynchronizationUtils</div><div class="line">   public static void triggerAfterCommit() &#123;</div><div class="line">	invokeAfterCommit(TransactionSynchronizationManager.getSynchronizations());</div><div class="line">&#125;</div><div class="line"></div><div class="line">   public static void invokeAfterCommit(List&lt;TransactionSynchronization&gt; synchronizations) &#123;</div><div class="line">	if (synchronizations != null) &#123;</div><div class="line">		for (TransactionSynchronization synchronization : synchronizations) &#123;</div><div class="line">			synchronization.afterCommit();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至今为止，以上讨论的是弱一致性的业务场景，一致性要求比较高的，需要分布式事务或者其他的手段来实现。<br>而且需要注意的，afterCommit()中的操作是同步的，和业务操作在同一个响应时间内的，所以，尽量不要做一些耗时的操作。<br>afterCommit()中，除了直接发送消息到队列，也可以使用本地队列来优化，用来存储和异步发送消息，这样会快很多。</p>
<p>``</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/01/05/java/spring/spring-transactional-aop/" itemprop="url">
                  【spring】自我调用中transaction的常见问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-05T20:25:08+08:00" content="2016-01-05">
              2016-01-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/05/java/spring/spring-transactional-aop/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/05/java/spring/spring-transactional-aop/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><hr>
<p>最近有个实习生开发了一个job，这个job提测之后，测试那边很快反映有数据异常，看了下log发现已有几条异常信息，但我惊讶的是有数据不一致的问题。我浏览了一下代码，并没有发现什么问题，发现都有用Transactional和rollback声明（当时脑子有点短路，一时没有看出来），但直觉告诉我这种错误八成与事务处理不当有关。<br>既然如此只好debug一下，接着很快便知道了。</p>
<h2 id="代码大概是这样的"><a href="#代码大概是这样的" class="headerlink" title="代码大概是这样的"></a>代码大概是这样的</h2><hr>
<p><a href="https://github.com/niko2014/blog-demo/tree/master/java/starter-jpa-transaction-self-invoke" target="_blank" rel="external">示例代码</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    @Transactional(rollbackFor = Exception.class)</div><div class="line">    public void methodMain() throws Exception &#123;</div><div class="line">        int status = 5;</div><div class="line">        methodA(status);</div><div class="line">        try &#123;</div><div class="line">            methodB(status);        // 位置A</div><div class="line">//            memberOrderCopyService.methodB(status);     // 位置B</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        methodC(status);</div><div class="line">    &#125;</div><div class="line">    @Transactional(rollbackFor = Exception.class)</div><div class="line">    public void methodA(Integer status) &#123;</div><div class="line">        MemberOrder mo = memberOrderRepository.findOne(1L);</div><div class="line">        mo.setStatus(status);</div><div class="line">        memberOrderRepository.save(mo);</div><div class="line">    &#125;</div><div class="line">    @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)</div><div class="line">    public void methodB(Integer status) throws Exception &#123;</div><div class="line">        MemberOrder mo = memberOrderRepository.findOne(2L);</div><div class="line">        mo.setStatus(status);</div><div class="line">        memberOrderRepository.save(mo);</div><div class="line">        th();</div><div class="line">    &#125;</div><div class="line">    public void methodC(Integer status) throws Exception &#123;</div><div class="line">        MemberOrder mo = memberOrderRepository.findOne(3L);</div><div class="line">        mo.setStatus(status);</div><div class="line">        memberOrderRepository.save(mo);</div><div class="line">    &#125;</div><div class="line">    private void th() throws Exception &#123;</div><div class="line">        throw new Exception(&quot;test&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如上，methodB()中有一个持久化的操作，在那之后有可能会抛异常(th()方法)。<br>实习生的想法是，methodB()加一个注解@Transactional(rollbackFor)，想让methodB执行失败时回滚事务。<br>然而，这种是对spring aop不了解导致的错误。</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><hr>
<p>我对实习生说了这个错误之后，他却坚持这样是有效的。。没办法，只好以理服人。断点debug，翻源码。</p>
<p><img src="/images/spring-tx-aop/error_debug_01.png" alt=""></p>
<p>如上图，可看到methodB()的调用栈，发现methodMaster()是经过拦截器后调用的（Cglib生成代理对象的情况下，AOP拦截和回调可在<code>DynamicAdvisedInterceptor.intercept()</code>方法中找到，如下）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Override</div><div class="line">public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</div><div class="line">    Object oldProxy = null;</div><div class="line">    boolean setProxyContext = false;</div><div class="line">    Class&lt;?&gt; targetClass = null;</div><div class="line">    Object target = null;</div><div class="line">    try &#123;</div><div class="line">        if (this.advised.exposeProxy) &#123;</div><div class="line">            // Make invocation available if necessary.</div><div class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</div><div class="line">            setProxyContext = true;</div><div class="line">        &#125;</div><div class="line">        // May be null. Get as late as possible to minimize the time we</div><div class="line">        // &quot;own&quot; the target, in case it comes from a pool...</div><div class="line">        target = getTarget();</div><div class="line">        if (target != null) &#123;</div><div class="line">            targetClass = target.getClass();</div><div class="line">        &#125;</div><div class="line">        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</div><div class="line">        Object retVal;</div><div class="line">        // Check whether we only have one InvokerInterceptor: that is,</div><div class="line">        // no real advice, but just reflective invocation of the target.</div><div class="line">        if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</div><div class="line">            // We can skip creating a MethodInvocation: just invoke the target directly.</div><div class="line">            // Note that the final invoker must be an InvokerInterceptor, so we know</div><div class="line">            // it does nothing but a reflective operation on the target, and no hot</div><div class="line">            // swapping or fancy proxying.</div><div class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</div><div class="line">            retVal = methodProxy.invoke(target, argsToUse);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // We need to create a method invocation...</div><div class="line">            retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</div><div class="line">        &#125;</div><div class="line">        retVal = processReturnType(proxy, target, method, retVal);</div><div class="line">        return retVal;</div><div class="line">    &#125;</div><div class="line">    finally &#123;</div><div class="line">        if (target != null) &#123;</div><div class="line">            releaseTarget(target);</div><div class="line">        &#125;</div><div class="line">        if (setProxyContext) &#123;</div><div class="line">            // Restore old proxy.</div><div class="line">            AopContext.setCurrentProxy(oldProxy);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在在来看methodB()：</p>
<p><img src="/images/spring-tx-aop/error_debug_03_self_invoke.png" alt=""></p>
<p>很明显，methodB是在methodMaster()中调用的，<code>TransactionInterceptor</code>并没有拦截，因此@Transactional是无效的。</p>
<p>现在来对比一下，切换启用位置B代码（使用<code>memberOrderCopyService.methodB(status)</code>）的执行情况：</p>
<p><img src="/images/spring-tx-aop/error_debug_03_of_copy_service.png" alt=""></p>
<p>从上图可知，此时memberOrderCopyService.methodB()和原先的memberOrderService.methodMaster()都经过了TransactionInterceptor，然后通过代理invoke，这种是正确的，当有异常出现，事务也会正常回滚。</p>
<p>其实，这是一个简单的问题，通过推理也可以猜到，而且如果内部每个方法都用拦截器，会是一个很大的性能问题。</p>
<div style="display:none"><br>    FastClassBySpringCGLIB<br>    EnhancerBySpringCGLIB<br>    其实如果用Aspect也可以实现类似Transactional的功能，<br>    下次有空写一个<code>Aspect 和 Transactional</code>的对比。<br></div>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/12/30/books/self_ctrl/self_ctrl_6/" itemprop="url">
                  【书：自控力】（六） 低落的情绪 为何使人屈服于诱惑？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-30T00:00:00+08:00" content="2015-12-30">
              2015-12-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/books/" itemprop="url" rel="index">
                    <span itemprop="name">books</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/30/books/self_ctrl/self_ctrl_6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/30/books/self_ctrl/self_ctrl_6/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><hr>
<p><img src="/images/book_self_ctrl_6.png" alt=""></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/12/26/git/git_cmd/" itemprop="url">
                  git 常用命令清单
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-26T00:00:00+08:00" content="2015-12-26">
              2015-12-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/26/git/git_cmd/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/26/git/git_cmd/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>这个清单是基于<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单 - 阮一峰</a>的博客修改的， 加上了安装配置部分和一些demo例子，并补充了一些命令（不断更新）。</p>
<h1 id="常用-Git-命令清单"><a href="#常用-Git-命令清单" class="headerlink" title="常用 Git 命令清单"></a>常用 Git 命令清单</h1><blockquote>
<p>我每天使用 Git ，但是很多命令记不住。<br>　　一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt=""></p>
<blockquote>
<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。<br>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p>
</blockquote>
<h1 id="安装配置-niko"><a href="#安装配置-niko" class="headerlink" title="安装配置 - niko"></a>安装配置 - niko</h1><h2 id="ssh-key-简要流程"><a href="#ssh-key-简要流程" class="headerlink" title="ssh key 简要流程"></a>ssh key 简要流程</h2><ol>
<li>ssh-keygen -t rsa -C “foo@gmail.com”，选择生成位置（~/.ssh/foo_rsa）。</li>
<li><p>ssh-agent -s<br>若提示 <code>Could not open a connection to your authentication agent.</code>, 使用：</p>
<p> eval <code>ssh-agent -s</code></p>
</li>
<li><p>ssh-add ~/.ssh/foo_rsa</p>
</li>
<li>clip &lt; ~/.ssh/foo_rsa.pub</li>
<li>添加到远程服务器的ssh_keys；</li>
<li>git clone …</li>
</ol>
<h3 id="设置ssh配置"><a href="#设置ssh配置" class="headerlink" title="设置ssh配置"></a>设置ssh配置</h3><p>vim ~/.ssh/config</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Host dev</div><div class="line">    HostName dev.example.com</div><div class="line">    Port 22000</div><div class="line">    User fooey&lt;/p&gt;</div><div class="line">Host github.com</div><div class="line">    IdentityFile ~/.ssh/github.key</div><div class="line">Host oschina.net</div><div class="line">    IdentityFile ~/.ssh/id_rsa_osc</div><div class="line">Host github.com</div><div class="line">    IdentityFile ~/.ssh/id_rsa_github</div></pre></td></tr></table></figure>
<div style="display:none"><br><a href="http://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/" target="_blank" rel="external">http://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/</a><br></div>

<h1 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h1><ul>
<li><p>在当前目录新建一个Git代码库<br>$ git init</p>
</li>
<li><p>新建一个目录，将其初始化为Git代码库<br>$ git init [project-name]</p>
</li>
<li><p>下载一个项目和它的整个代码历史<br>$ git clone [url]</p>
</li>
</ul>
<h1 id="二、git-配置"><a href="#二、git-配置" class="headerlink" title="二、git 配置"></a>二、git 配置</h1><p>　　Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<ul>
<li><p>显示当前的Git配置<br>$ git config –list</p>
</li>
<li><p>编辑Git配置文件<br>$ git config -e [–global]</p>
</li>
<li><p>设置提交代码时的用户信息<br>$ git config [–global] user.name “[name]”<br>$ git config [–global] user.email “[email address]”</p>
</li>
<li><p>push pull 策略</p>
</li>
</ul>
<p>ref ： <a href="http://blog.angular.in/git-pushmo-ren-fen-zhi/" target="_blank" rel="external">http://blog.angular.in/git-pushmo-ren-fen-zhi/</a></p>
<p><code>push.default</code> 未设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">warning: push.default is unset; its implicit value is changing in</div><div class="line">Git 2.0 from &apos;matching&apos; to &apos;simple&apos;. To squelch this message</div><div class="line">and maintain the current behavior after the default changes, use:</div><div class="line"></div><div class="line">  git config --global push.default matching</div><div class="line"></div><div class="line">To squelch this message and adopt the new behavior now, use:</div><div class="line"></div><div class="line">  git config --global push.default simple</div><div class="line"></div><div class="line">When push.default is set to &apos;matching&apos;, git will push local branches</div><div class="line">to the remote branches that already exist with the same name.</div><div class="line"></div><div class="line">In Git 2.0, Git will default to the more conservative &apos;simple&apos;</div><div class="line">behavior, which only pushes the current branch to the corresponding</div><div class="line">remote branch that &apos;git pull&apos; uses to update the current branch.</div><div class="line"></div><div class="line">See &apos;git help config&apos; and search for &apos;push.default&apos; for further information.</div><div class="line">(the &apos;simple&apos; mode was introduced in Git 1.7.11. Use the similar mode</div><div class="line">&apos;current&apos; instead of &apos;simple&apos; if you sometimes use older versions of Git)</div></pre></td></tr></table></figure>
<p>git config –global push.default ‘option’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">option：</div><div class="line"></div><div class="line">nothing - push操作无效，除非显式指定远程分支，例如git push origin develop（我觉得。。。可以给那些不愿学git的同事配上此项）。</div><div class="line"></div><div class="line">current - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。</div><div class="line"></div><div class="line">upstream - push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。</div><div class="line"></div><div class="line">simple - simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程 upstream分支同名，否则会拒绝push操作。</div><div class="line"></div><div class="line">matching - push所有本地和远程两端都存在的同名分支。</div></pre></td></tr></table></figure>
<h1 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h1><ul>
<li><p>添加指定文件到暂存区<br>$ git add [file1] [file2] …</p>
</li>
<li><p>添加指定目录到暂存区，包括子目录<br>$ git add [dir]</p>
</li>
<li><p>添加当前目录的所有文件到暂存区<br>git add .<br>git add –all (对删除文件有效)</p>
</li>
<li><p>删除工作区文件，并且将这次删除放入暂存区<br>git rm [file1] [file2] …</p>
</li>
<li><p>停止追踪指定文件，但该文件会保留在工作区<br>git rm <code>--cached</code> [file]</p>
</li>
<li><p>取消放入暂存区<br>use “git reset HEAD <file>…” to unstage</file></p>
</li>
<li><p>改名文件，并且将这个改名放入暂存区<br>git mv [file-original] [file-renamed]</p>
</li>
<li><p>取消改名<br>git mv [file-renamed] [file-original]</p>
</li>
</ul>
<h1 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h1><hr>
<ul>
<li><p>提交暂存区到仓库区<br>git commit -m [message]</p>
</li>
<li><p>提交暂存区的指定文件到仓库区<br>git commit [file1] [file2] … -m [message]</p>
</li>
<li><p>提交工作区自上次commit之后的变化，直接到仓库区<br>git commit -a</p>
</li>
<li><p>提交时显示所有diff信息<br>git commit -v</p>
</li>
<li><p>使用一次新的commit，替代上一次提交</p>
</li>
<li>重做上一次commit，并包括指定文件的新变化</li>
<li>如果代码没有任何新变化，则用来改写上一次commit的提交信息<br>$ git commit <code>--amend</code> -m [message]<br>$ git commit –amend   …</li>
</ul>
<h1 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h1><ul>
<li><p>列出所有本地分支<br>$ git branch</p>
</li>
<li><p>列出所有远程分支<br>$ git branch -r</p>
</li>
<li><p>列出所有本地分支和远程分支<br>$ git branch -a</p>
</li>
<li><p>新建一个分支，但依然停留在当前分支<br>$ git branch [branch-name]</p>
</li>
<li><p>新建一个分支，并切换到该分支<br>$ git checkout -b [branch]</p>
</li>
<li><p>新建一个分支，指向指定commit<br>$ git branch [branch] [commit]</p>
</li>
<li><p>新建一个分支，与指定的远程分支建立追踪关系<br>$ git branch –track [branch] [remote-branch]</p>
</li>
<li><p>切换到指定分支，并更新工作区<br>$ git checkout [branch-name]</p>
</li>
<li><p>建立追踪关系，在现有分支与指定的远程分支之间<br>$ git branch –set-upstream [branch] [remote-branch]</p>
</li>
<li><p>合并指定分支到当前分支<br>$ git merge [branch]</p>
</li>
<li><p>选择一个commit，合并进当前分支<br>$ git <code>cherry-pick</code> [commit]</p>
</li>
<li><p>终止(abort) merge 操作：<br>$ git reset –hard HEAD<br><a href="http://stackoverflow.com/questions/101752/i-ran-into-a-merge-conflict-how-can-i-abort-the-merge" target="_blank" rel="external">http://stackoverflow.com/questions/101752/i-ran-into-a-merge-conflict-how-can-i-abort-the-merge</a></p>
</li>
<li><p>删除分支<br>$ git branch -d [branch-name]</p>
</li>
<li><p>删除远程分支<br>git push origin –delete <branchname><br>git push origin –delete<br>git branch -dr</branchname></p>
</li>
</ul>
<h1 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h1><ul>
<li><p>列出所有tag<br>$ git tag</p>
</li>
<li><p>新建一个tag在当前commit<br>git tag [tag]<br>注释：<br>git tag -a v1.4 -m ‘my version 1.4’</p>
</li>
<li><p>新建一个tag在指定commit<br>$ git tag [tag] [commit]</p>
</li>
<li><p>查看tag信息<br>$ git show [tag]</p>
</li>
<li><p>提交指定tag<br>$ git push [remote] [tag]</p>
</li>
<li><p>提交所有tag<br>$ git push [remote] –tags</p>
</li>
<li><p>新建一个分支，指向某个tag<br>$ git checkout -b [branch] [tag]</p>
</li>
</ul>
<h1 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h1><ul>
<li><p>显示有变更的文件<br>$ git status</p>
</li>
<li><p>GUI 审查代码<br>git difftool</p>
</li>
<li><p>显示当前分支的版本历史<br>$ git log</p>
</li>
<li><p>显示commit历史，以及每次commit发生变更的文件<br>$ git log –stat</p>
</li>
<li><p>显示某个文件的版本历史，包括文件改名<br>$ git log –follow [file]<br>$ git whatchanged [file]</p>
</li>
<li><p>显示指定文件相关的每一次diff<br>$ git log -p [file]</p>
</li>
<li><p>华丽的分支log<br>$ git log –graph –decorate –pretty=oneline –abbrev-commit develop  origin/develop  temp-branch</p>
</li>
<li><p>显示指定文件是什么人在什么时间修改过<br><code>git blame</code> [file]</p>
</li>
<li><p>显示暂存区和工作区的差异<br>git diff</p>
</li>
<li><p>显示暂存区和上一个commit的差异<br>$ git diff <code>--cached</code> []</p>
</li>
<li><p>显示工作区与当前分支最新commit之间的差异<br>$ git diff <code>HEAD</code></p>
</li>
<li><p>显示两次提交之间的差异<br>$ git diff [first-branch]…[second-branch]</p>
</li>
<li><p>显示某次提交的元数据和内容变化<br>$ git show [commit]</p>
</li>
<li><p>显示某次提交发生变化的文件<br>$ git show <code>--name-only</code> [commit]</p>
</li>
<li><p>显示某次提交时，某个文件的内容<br>$ git show [commit]:[filename]</p>
</li>
<li><p>显示当前分支的最近几次提交<br>git reflog</p>
<blockquote>
<p>Reference logs, or “reflogs”, record when the tips of branches and other references were updated in the local repository. Reflogs are useful in various Git commands, to specify the old value of a reference.</p>
</blockquote>
</li>
</ul>
<p>reflog可以看到被删除的记录(如)，而git log不能。</p>
<h1 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h1><hr>
<ul>
<li>下载远程仓库的所有变动<br>$ git fetch [remote]</li>
</ul>
<blockquote>
<p>Download objects and refs from another repository<br>用”git fetch”” 来执行”git pull”前半部分的工作， 但是这条命令并不会把抓下来的修改合并到当前分支里。</p>
</blockquote>
<ul>
<li><p>显示所有远程仓库<br>$ git remote -v</p>
</li>
<li><p>显示某个远程仓库的信息<br>$ git remote show [remote]</p>
</li>
<li><p>增加一个新的远程仓库，并命名<br>$ git remote add [shortname] [url]</p>
</li>
<li><p>取回远程仓库的变化，并与本地分支合并<br>$ git pull [remote] [branch]</p>
</li>
<li><p>上传本地指定分支到远程仓库<br>$ git push [remote] [branch]</p>
</li>
<li><p>推送本地指定的分支名到远程仓库 - niko<br>$ git push origin develop:develop_remote<br>$ git push <remote> <local branch="" name="">:<remote branch="" to="" push="" into=""></remote></local></remote></p>
</li>
<li><p>强行推送当前分支到远程仓库，即使有冲突<br>$ git push [remote] –force</p>
</li>
<li><p>推送所有分支到远程仓库<br>$ git push [remote] –all</p>
</li>
<li><p>with rebase<br>git pull –rebase</p>
</li>
</ul>
<h1 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h1><ul>
<li><p>恢复暂存区的指定文件到工作区<br>$ git checkout [file]</p>
</li>
<li><p>恢复某个commit的指定文件到工作区<br>$ git checkout [commit] [file]</p>
</li>
<li><p>恢复上一个commit的所有文件到工作区<br>$ git checkout .</p>
</li>
<li><p>取消commit<br>$ git reset –soft HEAD~</p>
</li>
<li><p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br>$ git reset [file]<br>REF: <a href="http://stackoverflow.com/questions/927358/how-do-you-undo-the-last-commit" target="_blank" rel="external">http://stackoverflow.com/questions/927358/how-do-you-undo-the-last-commit</a></p>
</li>
<li><p>重置暂存区与工作区，与上一次commit保持一致<br>$ git <code>reset --hard</code></p>
</li>
<li><p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br>$ git reset [commit]</p>
</li>
<li><p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br>$ git reset <code>--hard</code> [commit]</p>
</li>
<li><p>重置当前HEAD为指定commit，但保持暂存区和工作区不变<br>$ git reset <code>--keep</code> [commit]</p>
</li>
<li><p>undo reset<br>git reflog<br>git reset HEAD@{1}<br><a href="http://stackoverflow.com/questions/2510276/undoing-git-reset" target="_blank" rel="external">undo reset</a></p>
</li>
<li><p>新建一个commit，用来撤销指定commit</p>
</li>
<li><p>后者的所有变化都将被前者抵消，并且应用到当前分支<br>$ git <code>revert [commit]</code></p>
</li>
<li><p>恢复删除的分支<br>// TODO<br><a href="http://stackoverflow.com/questions/16793637/recover-deleted-branch-git" target="_blank" rel="external">http://stackoverflow.com/questions/16793637/recover-deleted-branch-git</a><br><a href="https://confluence.atlassian.com/bbkb/how-to-restore-a-deleted-branch-765757540.html" target="_blank" rel="external">https://confluence.atlassian.com/bbkb/how-to-restore-a-deleted-branch-765757540.html</a></p>
</li>
<li><p>TODO rebase<br>If you prefer to skip this patch,<br><a href="https://help.github.com/articles/resolving-merge-conflicts-after-a-git-rebase/" target="_blank" rel="external">https://help.github.com/articles/resolving-merge-conflicts-after-a-git-rebase/</a></p>
</li>
</ul>
<h1 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h1><ul>
<li><p>生成一个可供发布的压缩包<br>git archive<br>via：ruanyifeng.com</p>
</li>
<li><p>git rebase<br>使分支历史看起来像没有经过合并一样。</p>
</li>
<li><p>分支上一次合并的信息 - niko<br>git show –summary <code>git merge-base A B</code></p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/12/23/books/self_ctrl/self_ctrl_5/" itemprop="url">
                  【书：自控力】（五） 大脑的弥天大谎 为什么我们误把渴望当幸福？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-23T00:00:00+08:00" content="2015-12-23">
              2015-12-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/books/" itemprop="url" rel="index">
                    <span itemprop="name">books</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/23/books/self_ctrl/self_ctrl_5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/23/books/self_ctrl/self_ctrl_5/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><hr>
<p><img src="/images/book_self_ctrl_5.png" alt=""></p>
<p>##</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/12/20/linux/ten-cmd-linux-performance/" itemprop="url">
                  【转】 如何用十条命令在一分钟内检查Linux服务器性能
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-20T00:00:00+08:00" content="2015-12-20">
              2015-12-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/20/linux/ten-cmd-linux-performance/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/20/linux/ten-cmd-linux-performance/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过执行以下命令，可以在1分钟内对系统资源使用情况有个大致的了解。</p>
<p>其中一些命令需要安装sysstat包，有一些由procps包提供。这些命令的输出，有助于快速定位性能瓶颈，检查出所有资源（CPU、内存、磁盘IO等）的利用率（utilization）、饱和度（saturation）和错误（error）度量，也就是所谓的<a href="http://www.brendangregg.com/usemethod.html" target="_blank" rel="external">USE方法</a>。</p>
<p>下面我们来逐一介绍下这些命令，有关这些命令更多的参数和说明，请参照命令的手册。</p>
<h2 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ uptime</div><div class="line">23:51:26 up 21:31,  1 user,  load average: 30.02, 26.43, 19.02</div></pre></td></tr></table></figure>
<p>分别表示1分钟、5分钟、15分钟的平均负载情况</p>
<h2 id="dmesg-tail"><a href="#dmesg-tail" class="headerlink" title="dmesg | tail"></a>dmesg | tail</h2><p>该命令会输出系统日志，可以帮助排查性能问题（如内核的oom kill和一次TCP丢包等）。</p>
<h2 id="vmstat-1"><a href="#vmstat-1" class="headerlink" title="vmstat 1"></a>vmstat 1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">niko@ubuntu:~$ vmstat 1</div><div class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</div><div class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</div><div class="line"> 2  0   4176 2746396 160728 1916384    0    0    15    85   12   47  9  7 84  0  0</div><div class="line"> 0  0   4176 2746228 160728 1916416    0    0     0     0 2129 4270  3  4 93  0  0</div><div class="line"> 1  0   4176 2746420 160748 1916468    0    0     0   372 1865 3960  4  5 91  0  0</div><div class="line"> 0  0   4176 2744964 160748 1916416    0    0     0     0 2000 4256  2  4 93  0  0</div><div class="line"> 1  0   4176 2745316 160748 1916420    0    0     0     0 2032 4288  2  4 94  0  0</div><div class="line"> 0  0   4176 2745052 160748 1916420    0    0     0     0 2070 4496  1  5 94  0  0</div><div class="line"> 0  0   4176 2744984 160748 1916420    0    0     0     0 2099 4202  2  5 93  0  0</div></pre></td></tr></table></figure>
<p>vmstat(8) 命令，每行会输出一些系统核心指标，这些指标可以让我们更详细的了解系统状态。后面跟的参数1，表示每秒输出一次统计信息，表头提示了每一列的含义，这几介绍一些和性能调优相关的列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">FIELD DESCRIPTION FOR VM MODE</div><div class="line">   Procs</div><div class="line">       r: The number of runnable processes (running or waiting for run time).</div><div class="line">       b: The number of processes in uninterruptible sleep.</div><div class="line"></div><div class="line">   Memory</div><div class="line">       swpd: the amount of virtual memory used.</div><div class="line">       free: the amount of idle memory.</div><div class="line">       buff: the amount of memory used as buffers.</div><div class="line">       cache: the amount of memory used as cache.</div><div class="line">       inact: the amount of inactive memory.  (-a option)</div><div class="line">       active: the amount of active memory.  (-a option)</div><div class="line"></div><div class="line">   Swap</div><div class="line">       si: Amount of memory swapped in from disk (/s).</div><div class="line">       so: Amount of memory swapped to disk (/s).</div><div class="line"></div><div class="line">   IO</div><div class="line">       bi: Blocks received from a block device (blocks/s).</div><div class="line">       bo: Blocks sent to a block device (blocks/s).</div><div class="line"></div><div class="line">   System</div><div class="line">       in: The number of interrupts per second, including the clock.</div><div class="line">       cs: The number of context switches per second.</div></pre></td></tr></table></figure>
<p>r：等待在CPU资源的进程数。这个数据比平均负载更加能够体现CPU负载情况，数据中不包含等待IO的进程。如果这个数值大于机器CPU核数，那么机器的CPU资源已经饱和。<br>free：系统可用内存数（以千字节为单位），如果剩余内存不足，也会导致系统性能问题。下文介绍到的free命令，可以更详细的了解系统内存的使用情况。</p>
<p>si, so：交换区写入和读取的数量。如果这个数据不为0，说明系统已经在使用交换区（swap），机器物理内存已经不足。</p>
<p>us, sy, id, wa, st：这些都代表了CPU时间的消耗，它们分别表示用户时间（user）、系统（内核）时间（sys）、空闲时间（idle）、IO等待时间（wait）和被偷走的时间（stolen，一般被其他虚拟机消耗）。</p>
<p>上述这些CPU时间，可以让我们很快了解CPU是否出于繁忙状态。一般情况下，如果用户时间和系统时间相加非常大，CPU出于忙于执行指令。如果IO等待时间很长，那么系统的瓶颈可能在磁盘IO。</p>
<p>示例命令的输出可以看见，大量CPU时间消耗在用户态，也就是用户应用程序消耗了CPU时间。这不一定是性能问题，需要结合r队列，一起分析。</p>
<h2 id="mpstat-P-ALL-1"><a href="#mpstat-P-ALL-1" class="headerlink" title="mpstat -P ALL 1"></a>mpstat -P ALL 1</h2><p>显示每个CPU的使用情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">niko@ubuntu:~$ mpstat -P ALL 1</div><div class="line">Linux 3.13.0-39-generic (ubuntu) 	03/18/2016 	_x86_64_	(4 CPU)</div><div class="line"></div><div class="line">01:18:13 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</div><div class="line">01:18:14 PM  all    8.70    0.00   18.84    0.58    0.00    1.45    0.00    0.00    0.00   70.43</div><div class="line">01:18:14 PM    0    7.06    0.00   16.47    0.00    0.00    2.35    0.00    0.00    0.00   74.12</div><div class="line">01:18:14 PM    1    7.78    0.00   18.89    1.11    0.00    2.22    0.00    0.00    0.00   70.00</div><div class="line">01:18:14 PM    2   11.76    0.00   17.65    2.35    0.00    1.18    0.00    0.00    0.00   67.06</div><div class="line">01:18:14 PM    3    8.24    0.00   21.18    0.00    0.00    0.00    0.00    0.00    0.00   70.59</div></pre></td></tr></table></figure>
<h2 id="pidstat-1"><a href="#pidstat-1" class="headerlink" title="pidstat 1"></a>pidstat 1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ pidstat 1</div><div class="line">Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    _x86_64_    (32 CPU)</div><div class="line">07:41:02 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</div><div class="line">07:41:03 PM     0         9    0.00    0.94    0.00    0.94     1  rcuos/0</div><div class="line">07:41:03 PM     0      4214    5.66    5.66    0.00   11.32    15  mesos-slave</div><div class="line">07:41:03 PM     0      4354    0.94    0.94    0.00    1.89     8  java</div><div class="line">07:41:03 PM     0      6521 1596.23    1.89    0.00 1598.11    27  java</div><div class="line">07:41:03 PM     0      6564 1571.70    7.55    0.00 1579.25    28  java</div><div class="line">07:41:03 PM 60004     60154    0.94    4.72    0.00    5.66     9  pidstat</div><div class="line">07:41:03 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</div><div class="line">07:41:04 PM     0      4214    6.00    2.00    0.00    8.00    15  mesos-slave</div><div class="line">07:41:04 PM     0      6521 1590.00    1.00    0.00 1591.00    27  java</div><div class="line">07:41:04 PM     0      6564 1573.00   10.00    0.00 1583.00    28  java</div><div class="line">07:41:04 PM   108      6718    1.00    0.00    0.00    1.00     0  snmp-pass</div><div class="line">07:41:04 PM 60004     60154    1.00    4.00    0.00    5.00     9  pidstat</div><div class="line">^C</div></pre></td></tr></table></figure>
<p>pidstat命令输出进程的CPU占用率，该命令会持续输出，并且不会覆盖之前的数据，可以方便观察系统动态。如上的输出，可以看见两个JAVA进程占用了将近1600%的CPU时间，既消耗了大约16个CPU核心的运算资源。</p>
<h2 id="iostat-xz-1"><a href="#iostat-xz-1" class="headerlink" title="iostat -xz 1"></a>iostat -xz 1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ iostat -xz 1</div><div class="line"></div><div class="line">Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015  _x86_64_ (32 CPU)</div><div class="line"></div><div class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</div><div class="line">          73.96    0.00    3.73    0.03    0.06   22.21</div><div class="line"></div><div class="line">Device:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class="line">xvda        0.00     0.23    0.21    0.18     4.52     2.08    34.37     0.00    9.98   13.80    5.42   2.44   0.09</div><div class="line">xvdb        0.01     0.00    1.02    8.94   127.97   598.53   145.79     0.00    0.43    1.78    0.28   0.25   0.25</div><div class="line">xvdc        0.01     0.00    1.02    8.86   127.79   595.94   146.50     0.00    0.45    1.82    0.30   0.27   0.26</div><div class="line">dm-0        0.00     0.00    0.69    2.32    10.47    31.69    28.01     0.01    3.23    0.71    3.98   0.13   0.04</div><div class="line">dm-1        0.00     0.00    0.00    0.94     0.01     3.78     8.00     0.33  345.84    0.04  346.81   0.01   0.00</div><div class="line">dm-2        0.00     0.00    0.09    0.07     1.35     0.36    22.50     0.00    2.55    0.23    5.62   1.78   0.03</div><div class="line">[...]</div><div class="line">^C</div></pre></td></tr></table></figure>
<p>iostat命令主要用于查看机器磁盘IO情况。该命令输出的列，主要含义是：</p>
<p>r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。</p>
<p>await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。</p>
<p>avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。</p>
<p>%util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。<br>如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。</p>
<h2 id="free-m"><a href="#free-m" class="headerlink" title="free -m"></a><code>free</code> -m</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ free -m</div><div class="line">             total       used       free     shared    buffers     cached</div><div class="line">Mem:        245998      24545     221453         83         59        541</div><div class="line">-/+ buffers/cache:      23944     222053</div><div class="line">Swap:            0          0          0</div></pre></td></tr></table></figure>
<p>free命令可以查看系统内存的使用情况，-m参数表示按照兆字节展示。最后两列分别表示用于IO缓存的内存数，和用于文件系统页缓存的内存数。需要注意的是，第二行-/+ buffers/cache，看上去缓存占用了大量内存空间。这是Linux系统的内存使用策略，尽可能的利用内存，如果应用程序需要内存，这部分内存会立即被回收并分配给应用程序。因此，这部分内存一般也被当成是可用内存。</p>
<p>如果可用内存非常少，系统可能会动用交换区（如果配置了的话），这样会增加IO开销（可以在iostat命令中提现），降低系统性能。</p>
<h2 id="网络吞吐"><a href="#网络吞吐" class="headerlink" title="网络吞吐"></a>网络吞吐</h2><p><code>sar -n DEV 1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sar -n DEV 1</div><div class="line">Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015     _x86_64_    (32 CPU)</div><div class="line">12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</div><div class="line">12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00</div><div class="line">12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00</div><div class="line">12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</div><div class="line">12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</div><div class="line">12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00</div><div class="line">12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00</div><div class="line">12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</div><div class="line">^C</div></pre></td></tr></table></figure>
<p>sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和。如示例输出中，eth0网卡设备，吞吐率大概在22 Mbytes/s，既176 Mbits/sec，没有达到1Gbit/sec的硬件上限。</p>
<p><code>sar -n TCP,ETCP 1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sar -n TCP,ETCP 1</div><div class="line">Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    _x86_64_    (32 CPU)</div><div class="line">12:17:19 AM  active/s passive/s    iseg/s    oseg/s</div><div class="line">12:17:20 AM      1.00      0.00  10233.00  18846.00</div><div class="line">12:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s</div><div class="line">12:17:20 AM      0.00      0.00      0.00      0.00      0.00</div><div class="line">12:17:20 AM  active/s passive/s    iseg/s    oseg/s</div><div class="line">12:17:21 AM      1.00      0.00   8359.00   6039.00</div><div class="line">12:17:20 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s</div><div class="line">12:17:21 AM      0.00      0.00      0.00      0.00      0.00</div><div class="line">^C</div></pre></td></tr></table></figure>
<p>sar命令在这里用于查看TCP连接状态，其中包括：</p>
<p>active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；<br>passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；<br>retrans/s：每秒TCP重传数量；</p>
<p>atmptf/s<br>     The number of times per second TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times  per  second  TCP  connections<br>     have made a direct transition to the LISTEN state from the SYN-RCVD state [tcpAttemptFails].</p>
<p>estres/s<br>     The number of times per second TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state [tcpEstabResets].</p>
<p>retrans/s<br>     The total number of segments retransmitted per second - that is, the number of TCP segments transmitted containing one or more previously transmitted octets [tcpRetransSegs].</p>
<p>isegerr/s<br>     The total number of segments received in error (e.g., bad TCP checksums) per second [tcpInErrs].</p>
<p>TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包。</p>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h2><p>top命令包含了前面好几个命令的检查的内容。比如系统负载情况（uptime）、系统内存使用情况（free）、系统CPU使用情况（vmstat）等。因此通过这个命令，可以相对全面的查看系统负载的来源。同时，top命令支持排序，可以按照不同的列排序，方便查找出诸如内存占用最多的进程、CPU占用率最高的进程等。</p>
<p>但是，top命令相对于前面一些命令，输出是一个瞬间值，如果不持续盯着，可能会错过一些线索。这时可能需要暂停top命令刷新，来记录和比对数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>排查Linux服务器性能问题还有很多工具，上面介绍的一些命令，可以帮助我们快速的定位问题。例如前面的示例输出，多个证据证明有JAVA进程占用了大量CPU资源，之后的性能调优就可以针对应用程序进行。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p>【1】原文：<a href="http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html" target="_blank" rel="external">Netflix性能工程团队的这篇博文</a><br>【2】 <a href="http://www.infoq.com/cn/news/2015/12/linux-performance?utm_campaign=rightbar_v2&amp;utm_source=infoq&amp;utm_medium=news_link&amp;utm_content=link_text" target="_blank" rel="external">金灵杰 译 InfoQ</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/12/19/linux/install/install_vmware_on_ubuntu/" itemprop="url">
                  在ubuntu上安装vmware
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-19T00:00:00+08:00" content="2015-12-19">
              2015-12-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/19/linux/install/install_vmware_on_ubuntu/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/19/linux/install/install_vmware_on_ubuntu/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="install-vmware-on-ubuntu"><a href="#install-vmware-on-ubuntu" class="headerlink" title="install vmware on ubuntu"></a>install vmware on ubuntu</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">download VMware-Workstation-Full-10.0.6-2700073.x86_64.bundle</div><div class="line">chmod u+x ./VMware-Workstation-Full-10.0.6-2700073.x86_64.bundle</div><div class="line">./VMware-Workstation-Full-10.0.6-2700073.x86_64.bundle</div></pre></td></tr></table></figure>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="super-键被宿主机拦截"><a href="#super-键被宿主机拦截" class="headerlink" title="super 键被宿主机拦截"></a>super 键被宿主机拦截</h2><p><a href="http://askubuntu.com/questions/485303/how-do-i-stop-ubuntu-from-intercepting-the-super-key-when-running-vmware" target="_blank" rel="external">解决方法</a>是:</p>
<blockquote>
<p>Pressing the Super key invokes the Unity Dash.<br>Pressing and holding the Super key invokes the keyboard shortcut overlay.<br>I suspect you are doing the later, based on your description.<br>Nevertheless, you could change the key used to invoke the Unity Dash using Unity Tweak Tool. This way, VMware will get your key-press signal immediately, when you press Super.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">Install Unity Tweak Tool</div><div class="line"></div><div class="line">sudo apt-get install unity-tweak-tool</div><div class="line"></div><div class="line">Launch Unity Tewak Tool.</div><div class="line"></div><div class="line">In the Unity section, select Additional.</div><div class="line"></div><div class="line">Click on &lt;Super&gt; next to Show the launcher.</div><div class="line"></div><div class="line">Select a different key (or key-combination) to invoke the launcher.</div></pre></td></tr></table></figure>
<h2 id="cached-Memory"><a href="#cached-Memory" class="headerlink" title="cached Memory"></a>cached Memory</h2><p>有同学反应, 在关闭vmware后, free内存并没有增加, 大概是下面这样: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">top - 11:59:35 up  3:14, 13 users,  load average: 0.49, 0.52, 0.51</div><div class="line">Tasks: 264 total,   3 running, 261 sleeping,   0 stopped,   0 zombie</div><div class="line">%Cpu(s):  4.8 us,  2.9 sy,  0.0 ni, 92.0 id,  0.2 wa,  0.1 hi,  0.0 si,  0.0 st</div><div class="line">KiB Mem:  16380532 total, 12103952 used,  4276580 free,  3168896 buffers</div><div class="line">KiB Swap:  8386556 total,        0 used,  8386556 free.  5171564 cached Mem</div><div class="line"></div><div class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                        </div><div class="line"> 6520 niko      20   0 4635876 971856  35672 S   4.6  5.9  15:55.71 java                                           </div><div class="line">10006 niko      20   0 2750752 365712 101492 S   1.7  2.2   0:58.00 et</div></pre></td></tr></table></figure>
<p>如上, 我的是16G内存的机子, 但是显示使用了12G, 刚才关闭了5G的vmware虚拟机, 但是内存仍在<code>cached Mem</code>中.</p>
<p>其实, 当你执行复制文件时, 也是这样的, 不用担心, 相关内容请看另一篇博客.<br>// TODO</p>
<p>#</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/12/01/java/utils/java_dir_watchdog/" itemprop="url">
                  java版目录watchdog
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-01T00:00:00+08:00" content="2015-12-01">
              2015-12-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/01/java/utils/java_dir_watchdog/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/01/java/utils/java_dir_watchdog/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>工作中我们经常会用到监听目录的功能, 当目录中有文件增加删除等操作时, 执行某些任务. 如果是Java来写, 怎么做呢 ?</p>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>实现这个功能, 我们要使用到<code>WatchService</code>和<code>Path</code>这两个东西, 首先创建一个WatchService:</p>
<pre><code>WatchService watcher = FileSystems.getDefault().newWatchService();
</code></pre><p>接着就可以注册这个WatchService到某个Path了:</p>
<pre><code>Path dir = ...;
WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);
`ENTRY_CREATE`等事件定义在`StandardWatchEventKinds`中.
</code></pre><p>注册后, 我们使用<code>WatchService.take()</code>就可以获取目录变更的事件了, 若没有, 则wait .</p>
<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><p>接下来就是写一个工具类<code>WatchDirUtils</code>, 用来接收和注册监听请求及回调.</p>
<p>相对于<code>WatchDirUtils</code>, 客户端的需求无非就两个, 一个是要监听的目录, 另一个是变更时的Callback. 我们可以封装成一个类.</p>
<p>我们暂且定义<code>WatchPath</code>和<code>WatchCallback</code>两个接口:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface WatchPath &#123;</div><div class="line">    public java.nio.file.Path getPath();</div><div class="line">&#125;</div><div class="line">public interface WatchCallback &#123;</div><div class="line">    public void handle(WatchEvent&lt;?&gt; event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后, 定义一个<code>WatchRequest</code>接口, 继承<code>WatchPath</code>和<code>WatchCallback</code>, 同时要求返回是否递归监听.<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface WatchRequest extends WatchPath, WatchCallback &#123;</div><div class="line">    public boolean isRecursive();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口定义好了, 接下来就是实现了, 我们新建一个<code>DebugWatchRequest</code>实现类,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class DebugWatchRequest implements WatchRequest &#123;</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    public void handle(WatchEvent&lt;Path&gt; ev) &#123;</div><div class="line">        Path name = ev.context();</div><div class="line">        Path child = dir.resolve(name);</div><div class="line">        System.out.format(&quot;%s: %s\n&quot;, event.kind().name(), child);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>封装好了watch请求, 只需要定义一个静态方法, 把请求传入即可.</p>
<pre><code>WatchDirUtils.register(new DebugWatchRequest(Path dir));
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void register(WatchRequest watchRequest) throws IOException &#123;</div><div class="line">        if (started.compareAndSet(false, true)) &#123;</div><div class="line">            init();</div><div class="line">        &#125;</div><div class="line">        if (serviceDown.get()) &#123;</div><div class="line">            throw new Exception(&quot;watch service down.&quot;);</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            Path dir = watchRequest.getPath();</div><div class="line">            if (watchRequest.isRecursive()) &#123;</div><div class="line">                System.out.format(&quot;Scanning %s ...\n&quot;, dir);</div><div class="line">                registerRecursive(dir, watchRequest);</div><div class="line">                System.out.println(&quot;Done.&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                registerNonRecursive(watchRequest);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当该方法第一次被调用时, 会进行初始化:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static void init() throws IOException &#123;</div><div class="line">        watcher = FileSystems.getDefault().newWatchService();</div><div class="line">        keysToWatchRequest = new ConcurrentHashMap&lt;&gt;();</div><div class="line">        trace = true;</div><div class="line"></div><div class="line">        // 启动线程来处理事件</div><div class="line">        ExecutorService exec = Executors.newSingleThreadExecutor();</div><div class="line">        exec.execute(new EventProcessor());</div><div class="line"></div><div class="line">        serviceDown.set(false);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>初始化包括新建watcher, 还有keysToWatchRequest(<br>在前面的介绍中, 我们已经知道, register某个目录后, 会有一个WatchKey返回, 所以需要有一个Map来关联WatchKey和Callback ).</p>
<p>最后启动一个线程来从watcher获取变更的事件, 并调用对应的Callback去handle该事件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// EventProcessor</div><div class="line"></div><div class="line">private static class EventProcessor implements Runnable &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            while (!Thread.interrupted()) &#123;</div><div class="line">                // wait for key to be signalled</div><div class="line">                WatchKey key;</div><div class="line">                try &#123;</div><div class="line">                    key = watcher.take();</div><div class="line">                &#125; catch (InterruptedException x) &#123;</div><div class="line">                    serviceDown();</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                WatchRequest watchRequest = keysToWatchRequest.get(key);</div><div class="line">                if (watchRequest == null) &#123;</div><div class="line">                    System.err.println(&quot;WatchKey not recognized (no cb) !!&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                Path dir = watchRequest.getPath();</div><div class="line">                if (dir == null) &#123;</div><div class="line">                    System.err.println(&quot;WatchKey not recognized (no path) !!&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                for (WatchEvent&lt;?&gt; event: key.pollEvents()) &#123;</div><div class="line">                    WatchEvent.Kind kind = event.kind();</div><div class="line">                    // TBD - provide example of how OVERFLOW event is handled</div><div class="line">                    if (kind == OVERFLOW) &#123;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // handle</div><div class="line">                    watchRequest.handle(event);</div><div class="line"></div><div class="line">                    // Context for directory entry event is the file name of entry</div><div class="line">                    WatchEvent&lt;Path&gt; ev = cast(event);</div><div class="line">                    Path name = ev.context();</div><div class="line">                    Path child = dir.resolve(name);</div><div class="line"></div><div class="line">                    // if directory is created, and watching recursively, then</div><div class="line">                    // register it and its sub-directories</div><div class="line">                    if (watchRequest.isRecursive() &amp;&amp; (kind == ENTRY_CREATE)) &#123;</div><div class="line">                        try &#123;</div><div class="line">                            if (Files.isDirectory(child, NOFOLLOW_LINKS)) &#123;</div><div class="line">                                registerRecursive(child, new DebugWatchRequest(child).setIsRecursive(true));</div><div class="line">                            &#125;</div><div class="line">                        &#125; catch (IOException x) &#123;</div><div class="line">                            // ignore to keep sample readbale</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // reset key and remove from set if directory no longer accessible</div><div class="line">                boolean valid = key.reset();</div><div class="line">                if (!valid) &#123;</div><div class="line">                    keysToWatchRequest.remove(key);</div><div class="line"></div><div class="line">                    // all directories are inaccessible</div><div class="line">                    if (keysToWatchRequest.isEmpty()) &#123;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            serviceDown();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private void serviceDown() &#123;</div><div class="line">            serviceDown.set(true);</div><div class="line">            // TODO REPORT IT</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p>这个demo实现了一个简单的目录watch功能, 还有许多地方需要改进. 比如:</p>
<ul>
<li><strong>InterruptedException等异常 及 客户端自定义通知方</strong></li>
</ul>
<p>当发生interrupt时, 应该停止服务释放资源, 进行记录日志并通过一些report通知给中控或相关人员, 关闭WatchService等 不过也应支持一下客户端自定义通知方式.<br>同时,  OVERFLOW等异常也要有对应的处理方式, 这个WatchService也不能100%保证可靠, 可以采取一些定时扫描的其他措施来弥补.</p>
<ul>
<li><strong>事件的处理和Callback的调用效率</strong></li>
</ul>
<p>目前的事件处理线程是只有一个的, 而且Callback的handle()时同步调用的.</p>
<p><strong> 那能够改成异步的呢 ? </strong></p>
<p>这个要看情况.<br>如果这个回调操作是次要业务, 那就不能使用异步. 因为如果一瞬间促发了许多回调, 那么这些回调同时运行, 极有可能迅速占用系统功能, 影响主业务, 甚至崩溃.<br>使用异步是有一定风险的, 不过开多几个线程还是可以考虑的.</p>
<ul>
<li><strong>支持多个WatchCallback</strong></li>
</ul>
<p>这个demo支持一个WatchKey对应一个Callback, 当有新的到来时, 就会覆盖旧的, 这个明显不太好. 不过要支持多个WatchCallback也很容易修改.</p>
<ul>
<li><strong>增加取消注册的功能</strong></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><hr>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html" target="_blank" rel="external">https://docs.oracle.com/javase/tutorial/essential/io/notification.html</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="niko" itemprop="image"/>
          <p class="site-author-name" itemprop="name">niko</p>
        </div>
        <p class="site-description motion-element" itemprop="description">去发现更大的世界！</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">58</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">49</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">136</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">niko</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"niko2014"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
